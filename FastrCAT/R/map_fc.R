#' @title Mapping of FastCAT data
#'
#' @description Once make_dataframe_fc() has been run, then map_fc can be
#' used. This function makes a station map from the dataframe generated.
#' The rendered map will be located in the plot folder within the current
#' folder.
#' @param current_path The path to the directory where the .csv file
#' generated by make_dataframe_fc is located.
#' @param map_type Determines the type of map which will be returned. The
#' default map is a station map. Map types are Stations: returns map of
#' station locations, Sample intensity: returns a map of sampling intesity
#' for each 0.3 decimal degrees which is around 30km for the regions that are
#' sampled hexagon, Salinity and Temperature: return an interpolated map using
#' inverse distance weighting method, set on a 0.25 decimal degree grid for
#' the average of the depth_range specified. If depth_range remains as NA,
#' then the entire water column will be averaged. Map types are as follows and
#' should be quoted: "Stations", "Sample Intensity", "Salinity", and
#' "Temperature".
#' @param depth_range The desired depth range for either the "Salinity" or
#' "Temperature". If the parameter is left as NA, then the entire water
#' column will be averaged.Takes a two value vector, a minimum and maximum of
#' desired depth range. For example a depth range of 5-10 meters would be
#' entered as such c(5,10).
#' @param st_names Adds the station names to the station map. This is
#' set to FALSE. In most cases adding station names makes the map busy.
#' Set to TRUE if you want station names.
#' @return A map of the desired type and depth range for a single cruise.
#' @export map_fc



map_fc <- function(current_path,
                   map_type = "Stations",
                   depth_range = NA,
                   st_names = FALSE){

# find and read in the file created by make_dataframe_fc()---------------------

fc_data <- readr::read_csv(list.files(path = current_path,
                                      pattern = "\\EcoDAAT.csv$",
                                      ignore.case = TRUE,
                                      include.dirs = TRUE,
                                      full.names = TRUE),
                                    col_types = readr::cols_only(
                                     CRUISE = readr::col_character(),
                                     STATION_NAME = readr::col_integer(),
                                     HAUL_NAME = readr::col_integer(),
                                     FOCI_GRID = readr::col_character(),
                                     DATE = readr::col_date(),
                                     LAT = readr::col_double(),
                                     LON = readr::col_double(),
                                     DEPTH_BOTTOM = readr::col_integer(),
                                     DEPTH = readr::col_integer(),
                                     TEMPERATURE1 = readr::col_double(),
                                     SALINITY1 = readr::col_double()))

# Check for plot folder--------------------------------------------------------

if(dir.exists(paste(current_path,"/plots",sep = "")) == FALSE){

  dir.create(paste(current_path,"/plots",sep = ""))
}


# bring in the shape files to make the basemap --------------------------------

MAP <- sf::st_read(dsn = system.file("extdata", package = "FastrCAT"),
                   layer = "Alaska_dcw_polygon_Project", quiet = TRUE)

# tranform into WGS84 coordinate system----------------------------------------

MAP <- sf::st_transform(MAP, "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

# bring in 200m bathymetry contour --------------------------------------------

BATH_200 <- sf::st_read(dsn = system.file("extdata", package = "FastrCAT"),
                        layer = "ne_10m_bathymetry_K_200", quiet = TRUE)

# transform into WGS84 coordinate system---------------------------------------

BATH_200 <- sf::st_transform(BATH_200,
                         "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

# coordinate bounding box for map----------------------------------------------

fc_xlim <- c(min(fc_data$LON, na.rm = TRUE) - 2,
             max(fc_data$LON, na.rm = TRUE) + 2)
fc_ylim <- c(min(fc_data$LAT, na.rm = TRUE) - 2,
             max(fc_data$LAT, na.rm = TRUE) + 2)

# Map directory----------------------------------------------------------------

map_dir_name <- if(map_type == "Stations" | map_type == "Sample Intensity"){

  paste(current_path, "plots",paste(unique(fc_data$CRUISE),
                            "_", map_type,".png",sep = ""), sep = "/")

} else if(map_type == "Salinity" & is.na(depth_range[1]) |
          map_type == "Temperature" & is.na(depth_range[1])){

  paste(current_path, "plots", paste(unique(fc_data$CRUISE),
                            "_", map_type,"_total water column",
                            ".png",sep = ""), sep = "/")

} else if(map_type == "Salinity" & !is.na(depth_range[1]) |
          map_type == "Temperature" & !is.na(depth_range[1])){

  paste(current_path, "plots", paste(unique(fc_data$CRUISE),
                            "_", map_type,"_",
                            min(depth_range, na.rm = TRUE), "_",
                            max(depth_range, na.rm = TRUE),
                            ".png",sep = ""), sep = "/")
}


map_title <- if(map_type == "Stations" | map_type == "Sample Intensity"){

    paste("Cruise ",unique(fc_data$CRUISE), ": ",map_type, sep = "")

    } else if(map_type == "Salinity" & is.na(depth_range[1]) |
              map_type == "Temperature" & is.na(depth_range[1])){

    paste("Cruise ",unique(fc_data$CRUISE), ": ","Mean ", map_type,
         ", total water column",sep = "")

    } else if(map_type == "Salinity" & !is.na(depth_range[1]) |
              map_type == "Temperature" & !is.na(depth_range[1])){

    paste("Cruise ",unique(fc_data$CRUISE), ": ", "Mean ", map_type," ",
        min(depth_range, na.rm = TRUE), " to ",
        max(depth_range, na.rm = TRUE), " meters depth", sep = "")
  }

# Dataframes and calculations for each map_type -------------------------------

map_data <- if(map_type == "Stations" | map_type == "Sample Intensity"){

  fc_data %>%
    dplyr::select(CRUISE, STATION_NAME, HAUL_NAME, LAT, LON)%>%
    tidyr::unite(STATION_HAUL, STATION_NAME, HAUL_NAME, sep = ".")%>%
    dplyr::distinct(STATION_HAUL, .keep_all = TRUE)

} else if(map_type == "Salinity"){

  MAP_IDW <- if(is.na(depth_range[1])){

    fc_data %>%
      dplyr::group_by(LAT,LON)%>%
      dplyr::summarise(SALINITY1 = mean(SALINITY1, na.rm = TRUE))%>%
      dplyr::select(LON, LAT, SALINITY1)%>%
      dplyr::mutate_at(dplyr::vars(-dplyr::group_cols()),
                       dplyr::funs(na.omit(.)))

  } else {
    fc_data %>% dplyr::filter(
      DEPTH >= min(depth_range, na.rm = TRUE) &
      DEPTH <= max(depth_range, na.rm = TRUE))%>%
      dplyr::group_by(LAT,LON)%>%
      dplyr::summarise(SALINITY1 = mean(SALINITY1, na.rm = TRUE))%>%
      dplyr::select(LON, LAT, SALINITY1)%>%
      dplyr::mutate_at(dplyr::vars(-dplyr::group_cols()),
                       dplyr::funs(na.omit(.)))
  }


  WGS84 <- sp::CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")

  MAP_IDW_SPAT <- sp::SpatialPointsDataFrame(coords = MAP_IDW[,c("LON","LAT")],
                                             data = MAP_IDW,
                                             proj4string = WGS84)

  # Make grid for idw by 0.25 degrees and convert to spatial object------------
  x.range <- as.integer(c(min(MAP_IDW$LON, na.rm = TRUE)-1,
                          max(MAP_IDW$LON, na.rm = TRUE)+1))

  y.range <- as.integer(c(min(MAP_IDW$LAT, na.rm = TRUE)-1,
                          max(MAP_IDW$LAT, na.rm = TRUE)+1))

  grd <- expand.grid(x = seq(from = x.range[1], to = x.range[2], by = 0.25),
                     y = seq(from = y.range[1], to = y.range[2], by = 0.25))

  sp::coordinates(grd) <- ~ x + y

  sp::gridded(grd) <- TRUE

  sp::proj4string(grd) <- WGS84

  # inverse distance weighting for variable------------------------------------
  idw <- gstat::idw(formula = MAP_IDW$SALINITY1 ~ 1,
                    locations = MAP_IDW_SPAT,
                    newdata = grd, idp = 3)

  idw.output <- as.data.frame(idw)
  names(idw.output)[1:3] <- c("LON","LAT","SALINITY1")

  # Makes a .4 degree buffer around each station------------------------------
  IDW_buff_WGS84 <- sf::st_as_sf(MAP_IDW, coords = c("LON","LAT"))%>%
    sf::st_buffer(., .4)%>%
    sf::st_as_sf(.)

  # Converts the idw dataframe to a raster and masks non-buffer area-----------
  IDW_raster <- raster::rasterFromXYZ(idw.output[,1:3],crs = WGS84)%>%
    raster::mask(., IDW_buff_WGS84)%>%
    raster::rasterToPoints(., spatial = TRUE)

  Out_crop <- cbind(IDW_raster@coords, IDW_raster@data)

  names(Out_crop) <- c("LON","LAT","SALINITY1")

  Out_crop

} else if(map_type == "Temperature"){


  MAP_IDW <- if(is.na(depth_range[1])){

    fc_data %>%
      dplyr::group_by(LAT,LON)%>%
      dplyr::summarise(TEMPERATURE1 = mean(TEMPERATURE1, na.rm = TRUE))%>%
      dplyr::select(LON, LAT, TEMPERATURE1)%>%
      dplyr::mutate_at(dplyr::vars(-dplyr::group_cols()),
                       dplyr::funs(na.omit(.)))

  } else {
    fc_data %>% dplyr::filter(
      DEPTH >= min(depth_range, na.rm = TRUE) &
        DEPTH <= max(depth_range, na.rm = TRUE))%>%
      dplyr::group_by(LAT,LON)%>%
      dplyr::summarise(TEMPERATURE1 = mean(TEMPERATURE1, na.rm = TRUE))%>%
      dplyr::select(LON, LAT, TEMPERATURE1)%>%
      dplyr::mutate_at(dplyr::vars(-dplyr::group_cols()),
                       dplyr::funs(na.omit(.)))
  }


  WGS84 <- sp::CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")

  MAP_IDW_SPAT <- sp::SpatialPointsDataFrame(coords = MAP_IDW[,c("LON","LAT")],
                                             data = MAP_IDW,
                                             proj4string = WGS84)

  # Make grid for idw by 0.25 degrees and convert to spatial object------------
  x.range <- as.integer(c(min(MAP_IDW$LON, na.rm = TRUE)-1,
                          max(MAP_IDW$LON, na.rm = TRUE)+1))

  y.range <- as.integer(c(min(MAP_IDW$LAT, na.rm = TRUE)-1,
                          max(MAP_IDW$LAT, na.rm = TRUE)+1))

  grd <- expand.grid(x = seq(from = x.range[1], to = x.range[2], by = 0.25),
                     y = seq(from = y.range[1], to = y.range[2], by = 0.25))

  sp::coordinates(grd) <- ~ x + y

  sp::gridded(grd) <- TRUE

  sp::proj4string(grd) <- WGS84

  # inverse distance weighting for variable------------------------------------
  idw <- gstat::idw(formula = MAP_IDW$TEMPERATURE1 ~ 1,
                    locations = MAP_IDW_SPAT,
                    newdata = grd, idp = 3)

  idw.output <- as.data.frame(idw)
  names(idw.output)[1:3] <- c("LON","LAT","TEMPERATURE1")

  # Makes a .4 degree buffer around each station------------------------------
  IDW_buff_WGS84 <- sf::st_as_sf(MAP_IDW, coords = c("LON","LAT"))%>%
    sf::st_buffer(., .4)%>%
    sf::st_as_sf(.)

  # Converts the idw dataframe to a raster and masks non-buffer area-----------
  IDW_raster <- raster::rasterFromXYZ(idw.output[,1:3],crs = WGS84)%>%
    raster::mask(., IDW_buff_WGS84)%>%
    raster::rasterToPoints(., spatial = TRUE)

  Out_crop <- cbind(IDW_raster@coords, IDW_raster@data)

  names(Out_crop) <- c("LON","LAT","TEMPERATURE1")

  Out_crop


} else{
  warning("No such map_type name, check spelling.")
}


# Plot object by map_type to add to map ---------------------------------------

map_choice <- if(map_type == "Stations"){

  if(st_names == TRUE){

  ggplot2::ggplot()+
    ggplot2::geom_point(ggplot2::aes(LON, LAT), size = 2, shape = 21,
                                      color = "black", fill = "#7394b5",
                                      data = map_data)+
    ggrepel::geom_text_repel(ggplot2::aes(LON, LAT, label = STATION_HAUL),
                             size = 5, color = "black",
                             data = map_data)

  }else if (st_names == FALSE){
    ggplot2::ggplot()+
      ggplot2::geom_point(ggplot2::aes(LON, LAT), size = 2, shape = 21,
                          color = "black", fill = "#7394b5",
                          data = map_data)
  }

} else if(map_type == "Sample Intensity"){

  intensity_color <- c("#013565", "#1C3983", "#3C3E87",
                       "#524685", "#664D83", "#785383", "#8C5A82", "#A05F7F",
                       "#B66478", "#CC686D", "#E0705D", "#EF7B4C", "#F78C41",
                       "#FAA13D", "#F9B642", "#F5CD4D", "#EFE35B", "#E5FA6A")


  if(length(unique(map_data$CRUISE)) <= 2){

  ggplot2::ggplot()+
    ggplot2::geom_hex(ggplot2::aes(LON, LAT), binwidth = 0.5, alpha = 0.9,
                      data = map_data)+
    ggplot2::scale_fill_gradientn(colors = intensity_color,
                                  breaks = seq(1,10, by = 2),
                                  labels = seq(1,10, by = 2),
                                  limits = c(1,10),
                                  name = "Casts(n)")+
    ggplot2::scale_color_gradientn(colors = intensity_color,
                                   breaks = seq(1,10, by = 2),
                                   labels = seq(1,10, by = 2),
                                   limits = c(1,10))
  }else{

    ggplot2::ggplot()+
      ggplot2::geom_hex(ggplot2::aes(LON, LAT), binwidth = 1, alpha = 0.9,
                        data = map_data)+
      ggplot2::scale_fill_gradientn(colors = intensity_color,
                                    breaks = seq(1,40, by = 5),
                                    labels = seq(1,40, by = 5),
                                    limits = c(1,40),
                                    name = "Casts(n)")+
      ggplot2::scale_color_gradientn(colors = intensity_color,
                                     breaks = seq(1,40, by = 5),
                                     labels = seq(1,40, by = 5),
                                     limits = c(1,40))


  }
} else if(map_type == "Salinity"){

# The limits for salinity were set based on values from historical fastcat
# data. The low end is set at 27 psu and 1 + the high end 35. The mode for the
# salinity data was 33. Contour for salinity is set to .5 PSU.
  salinity_color <- c("#2B1470", "#2C1D8A", "#212F96", "#114293", "#08518F",
                      "#0E5E8B", "#1A6989", "#267488", "#318088", "#3A8B88",
                      "#439787", "#4BA385", "#56AF81", "#64BA7B", "#77C574",
                      "#91CF6C", "#B0D66C", "#CCDE78", "#E6E58A", "#FEEEA0")

  ggplot2::ggplot()+
    ggplot2::geom_tile(ggplot2::aes(x = LON, y = LAT, fill = SALINITY1), size = 1,
            data = map_data)+
    ggplot2::geom_contour(ggplot2::aes(x = LON, y = LAT, z = SALINITY1),
                          binwidth = 0.5,data = map_data,
                 color = "#f0ead6", size = .5)+
    ggplot2::scale_fill_gradientn(colors = salinity_color,
                                  breaks = seq(27,35, by = 2),
                                  labels = seq(27,35, by = 2),
                                  limits = c(27,35),
                                  name = expression(bold("PSU")))+
    ggplot2::scale_color_gradientn(colors = salinity_color,
                                   breaks = seq(27,35, by = 2),
                                   labels = seq(27,35, by = 2),
                                   limits = c(27,35))

} else if(map_type == "Temperature"){

# The limits for temperature were set on the low end the temperature at which
# seaeater freezes -2C and the high end of 18C which is 2 degrees higher than
# the highest recored temperature from all fastcat data. This will give wiggle
# room for higher temperatures in the future. The mode for temperature is 6C.
# Binwidth for the temperature contour is 1 degree C.

  temperature_color <- c("#0E0C71", "#1D159E", "#1D26C9", "#174CBB", "#2F63B3",
                         "#4977B2", "#658AB4", "#7F9DB9", "#9AAFC1", "#B6C3CD",
                         #"#D2D7DB" "#EEEDED" "#E0D2CF"
                         "#D6B8B1", "#CB9F93", "#C28676", "#B86E5A", "#AD543E",
                         "#A23925", "#931A11", "#7B0413", "#5D0311", "#41000B")

  ggplot2::ggplot()+
    ggplot2::geom_tile(ggplot2::aes(x = LON, y = LAT, fill = TEMPERATURE1), size = 1,
                       data = map_data)+
    ggplot2::geom_contour(ggplot2::aes(x = LON, y = LAT, z = TEMPERATURE1),
                          binwidth = 1, data = map_data,
                          color = "#4c7f7f", size = .25)+
    ggplot2::scale_fill_gradientn(colors = temperature_color,
                                  breaks = seq(-2,18, by = 4),
                                  labels = seq(-2,18, by = 4),
                                  limits = c(-2,18),
                                  name = expression(bold( ~degree~C )))+
    ggplot2::scale_color_gradientn(colors = temperature_color,
                                   breaks = seq(-2,18, by = 4),
                                   labels = seq(-2,18, by = 4),
                                   limits = c(-2,18))
} else{
  warning("No such map_type name, check spelling.")
}

# map--------------------------------------------------------------------------

fc_map <- map_choice +
              ggplot2::geom_sf(color = "#434e57", data = BATH_200[3], alpha = 0)+
              ggplot2::geom_sf(fill ="#a7ad94", color = "black", data = MAP[1])+
              ggspatial::annotation_scale(location = "bl", width_hint = 0.5,
                              unit_category = "metric")+
              ggplot2::coord_sf(xlim = fc_xlim, ylim = fc_ylim)+
              ggplot2::theme_bw()+
              ggplot2::xlab(label = "Longitude")+
              ggplot2::ylab(label = "Latitude")+
              ggplot2::ggtitle(label = map_title)+
              ggplot2::theme(
                axis.text.y = ggplot2::element_text(face = "bold", size = 12),
                axis.text.x = ggplot2::element_text(face = "bold", size = 12),
                axis.title = ggplot2::element_text(face = "bold", size = 14),
                title = ggplot2::element_text(face = "bold", size = 14),
                legend.key.height =  ggplot2::unit(36, "mm"),
                legend.key.width = ggplot2::unit(8, "mm"),
                legend.text = ggplot2::element_text(face = "bold", size = 12))

# write map to file-------------------------------------------------------
png(filename = map_dir_name, width = 250, height = 250, units = "mm",
    res = 350, bg = "transparent")

print(fc_map)

dev.off()

 }




